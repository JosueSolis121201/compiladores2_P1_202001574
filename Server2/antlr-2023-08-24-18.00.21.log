2023-08-24 18:00:21:170 grammar LogManager.java:25 before: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE STR (BLOCK (ALT 'String'))) (RULE CHAR (BLOCK (ALT 'Character'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE ELSE_IF (BLOCK (ALT 'else if'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE D_APPEND (BLOCK (ALT '.append'))) (RULE D_REMOVE (BLOCK (ALT '.remove'))) (RULE REPEATING (BLOCK (ALT 'repeating'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE STRUCT (BLOCK (ALT 'STRUCT'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE SELF_D (BLOCK (ALT 'self.'))) (RULE PUNTO (BLOCK (ALT '.'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE GUION_B (BLOCK (ALT '_'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE MAS_IGUAL (BLOCK (ALT '+='))) (RULE MENOS_IGUAL (BLOCK (ALT '-='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE SOLO_AND (BLOCK (ALT '&'))) (RULE IG (BLOCK (ALT '='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE MODULO (BLOCK (ALT '%'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE D_PTS (BLOCK (ALT ':'))) (RULE CORIZQ (BLOCK (ALT '['))) (RULE CORDER (BLOCK (ALT ']'))) (RULE COMA (BLOCK (ALT ','))) (RULE PUNTO_COMA (BLOCK (ALT ';'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-24 18:00:21:186 grammar LogManager.java:25 after: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE STR (BLOCK (ALT 'String'))) (RULE CHAR (BLOCK (ALT 'Character'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE ELSE_IF (BLOCK (ALT 'else if'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE D_APPEND (BLOCK (ALT '.append'))) (RULE D_REMOVE (BLOCK (ALT '.remove'))) (RULE REPEATING (BLOCK (ALT 'repeating'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE STRUCT (BLOCK (ALT 'STRUCT'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE SELF_D (BLOCK (ALT 'self.'))) (RULE PUNTO (BLOCK (ALT '.'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE GUION_B (BLOCK (ALT '_'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE MAS_IGUAL (BLOCK (ALT '+='))) (RULE MENOS_IGUAL (BLOCK (ALT '-='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE SOLO_AND (BLOCK (ALT '&'))) (RULE IG (BLOCK (ALT '='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE MODULO (BLOCK (ALT '%'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE D_PTS (BLOCK (ALT ':'))) (RULE CORIZQ (BLOCK (ALT '['))) (RULE CORDER (BLOCK (ALT ']'))) (RULE COMA (BLOCK (ALT ','))) (RULE PUNTO_COMA (BLOCK (ALT ';'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-24 18:00:21:434 grammar LogManager.java:25 before: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT asignacionstmt {}) (ALT switchstmt {}) (ALT whilestmt {}) (ALT forstmt {}) (ALT guardstmt {}) (ALT jumpstmt {}))) (RULE guardstmt (returns ) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ block LLAVEDER { }))) (RULE jumpstmt (returns ) (BLOCK (ALT CONTINUE {}) (ALT RETURN {}) (ALT BREAK {}) (ALT EPSILON))) (RULE whilestmt (returns ) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER { }))) (RULE forstmt (returns ) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER { }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER else_ifstmt elsestmt {}))) (RULE elsestmt (returns ) (BLOCK (ALT ELSE LLAVEIZQ block LLAVEDER {}) (ALT EPSILON))) (RULE else_ifstmt (returns ) (BLOCK (ALT else_ifstmt ELSE_IF expr LLAVEIZQ block LLAVEDER {}) (ALT EPSILON))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT reserv ID D_PTS types IG expr {}) (ALT reserv ID IG expr {}))) (RULE switchstmt (returns ) (BLOCK (ALT SWITCH expr LLAVEIZQ case defaultsts LLAVEDER {}))) (RULE defaultsts (returns ) (BLOCK (ALT DEFAULT D_PTS block {}) (ALT EPSILON))) (RULE case (returns ) (BLOCK (ALT case CASE expr D_PTS block {}) (ALT EPSILON))) (RULE asignacionstmt (returns ) (BLOCK (ALT ID ig_type expr {}))) (RULE ig_type (returns ) (BLOCK (ALT IG {}) (ALT IG_IG {}) (ALT MAS_IGUAL {}) (ALT MENOS_IGUAL {}))) (RULE reserv (returns ) (BLOCK (ALT VAR {}) (ALT LET {}))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CHAR {}) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (BLOCK (ALT MUL) (ALT DIV))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT ADD) (ALT SUB))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MAY_IG) (ALT MAYOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MEN_IG) (ALT MENOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT IG_IG) (ALT DIF))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op MAS_IGUAL) (= right expr) {}) (ALT (= left expr) (= op MENOS_IGUAL) (= right expr) {}) (ALT (= left expr) (= op MODULO) (= right expr) {}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-24 18:00:21:438 grammar LogManager.java:25 after: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT asignacionstmt {}) (ALT switchstmt {}) (ALT whilestmt {}) (ALT forstmt {}) (ALT guardstmt {}) (ALT jumpstmt {}))) (RULE guardstmt (returns ) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ block LLAVEDER { }))) (RULE jumpstmt (returns ) (BLOCK (ALT CONTINUE {}) (ALT RETURN {}) (ALT BREAK {}) (ALT EPSILON))) (RULE whilestmt (returns ) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER { }))) (RULE forstmt (returns ) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER { }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER else_ifstmt elsestmt {}))) (RULE elsestmt (returns ) (BLOCK (ALT ELSE LLAVEIZQ block LLAVEDER {}) (ALT EPSILON))) (RULE else_ifstmt (returns ) (BLOCK (ALT else_ifstmt ELSE_IF expr LLAVEIZQ block LLAVEDER {}) (ALT EPSILON))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT reserv ID D_PTS types IG expr {}) (ALT reserv ID IG expr {}))) (RULE switchstmt (returns ) (BLOCK (ALT SWITCH expr LLAVEIZQ case defaultsts LLAVEDER {}))) (RULE defaultsts (returns ) (BLOCK (ALT DEFAULT D_PTS block {}) (ALT EPSILON))) (RULE case (returns ) (BLOCK (ALT case CASE expr D_PTS block {}) (ALT EPSILON))) (RULE asignacionstmt (returns ) (BLOCK (ALT ID ig_type expr {}))) (RULE ig_type (returns ) (BLOCK (ALT IG {}) (ALT IG_IG {}) (ALT MAS_IGUAL {}) (ALT MENOS_IGUAL {}))) (RULE reserv (returns ) (BLOCK (ALT VAR {}) (ALT LET {}))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CHAR {}) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op MAS_IGUAL) (= right expr) {}) (ALT (= left expr) (= op MENOS_IGUAL) (= right expr) {}) (ALT (= left expr) (= op MODULO) (= right expr) {}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-24 18:00:21:440 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT asignacionstmt {}) (ALT switchstmt {}) (ALT whilestmt {}) (ALT forstmt {}) (ALT guardstmt {}) (ALT jumpstmt {}))) (RULE guardstmt (returns ) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ block LLAVEDER { }))) (RULE jumpstmt (returns ) (BLOCK (ALT CONTINUE {}) (ALT RETURN {}) (ALT BREAK {}) (ALT EPSILON))) (RULE whilestmt (returns ) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER { }))) (RULE forstmt (returns ) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER { }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER else_ifstmt elsestmt {}))) (RULE elsestmt (returns ) (BLOCK (ALT ELSE LLAVEIZQ block LLAVEDER {}) (ALT EPSILON))) (RULE else_ifstmt (returns ) (BLOCK (ALT else_ifstmt ELSE_IF expr LLAVEIZQ block LLAVEDER {}) (ALT EPSILON))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT reserv ID D_PTS types IG expr {}) (ALT reserv ID IG expr {}))) (RULE switchstmt (returns ) (BLOCK (ALT SWITCH expr LLAVEIZQ case defaultsts LLAVEDER {}))) (RULE defaultsts (returns ) (BLOCK (ALT DEFAULT D_PTS block {}) (ALT EPSILON))) (RULE case (returns ) (BLOCK (ALT case CASE expr D_PTS block {}) (ALT EPSILON))) (RULE asignacionstmt (returns ) (BLOCK (ALT ID ig_type expr {}))) (RULE ig_type (returns ) (BLOCK (ALT IG {}) (ALT IG_IG {}) (ALT MAS_IGUAL {}) (ALT MENOS_IGUAL {}))) (RULE reserv (returns ) (BLOCK (ALT VAR {}) (ALT LET {}))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CHAR {}) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op MAS_IGUAL) (= right expr) {}) (ALT (= left expr) (= op MENOS_IGUAL) (= right expr) {}) (ALT (= left expr) (= op MODULO) (= right expr) {}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-24 18:00:21:440 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR SwiftGrammarLexer OPTIONS (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) RULES)
2023-08-24 18:00:21:453 left-recursion LogManager.java:25 else_ifstmt returns []
    :   ( {}  
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> ELSE_IF<tokenIndex=300> expr<tokenIndex=302> LLAVEIZQ<tokenIndex=304> block<tokenIndex=306> LLAVEDER<tokenIndex=308>   {}
        )*
    ;
2023-08-24 18:00:21:455 grammar LogManager.java:25 added: (RULE else_ifstmt (returns ) (BLOCK (ALT (BLOCK (ALT {})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (ELSE_IF (ELEMENT_OPTIONS (= tokenIndex 300))) (expr (ELEMENT_OPTIONS (= tokenIndex 302))) (LLAVEIZQ (ELEMENT_OPTIONS (= tokenIndex 304))) (block (ELEMENT_OPTIONS (= tokenIndex 306))) (LLAVEDER (ELEMENT_OPTIONS (= tokenIndex 308))) {}))))))
2023-08-24 18:00:21:455 left-recursion LogManager.java:25 case returns []
    :   ( {}  
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> CASE<tokenIndex=406>  expr<tokenIndex=408> D_PTS<tokenIndex=410> block<tokenIndex=412>   {}
        )*
    ;
2023-08-24 18:00:21:456 grammar LogManager.java:25 added: (RULE case (returns ) (BLOCK (ALT (BLOCK (ALT {})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (CASE (ELEMENT_OPTIONS (= tokenIndex 406))) (expr (ELEMENT_OPTIONS (= tokenIndex 408))) (D_PTS (ELEMENT_OPTIONS (= tokenIndex 410))) (block (ELEMENT_OPTIONS (= tokenIndex 412))) {}))))))
2023-08-24 18:00:21:459 left-recursion LogManager.java:25 expr returns [interfaces.Expression e]
    :   ( {} PARIZQ<tokenIndex=723> expr<tokenIndex=725> PARDER<tokenIndex=727> { $e = $expr.e } 
        | list=listArray<tokenIndex=735> { $e = $list.p} 
        | CORIZQ<tokenIndex=741> listParams<tokenIndex=743> CORDER<tokenIndex=745> { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) } 
        | NUMBER<tokenIndex=751>                             
    {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    } 
        | STRING<tokenIndex=757>
    {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    } 
        | TRU<tokenIndex=763> { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) } 
        | FAL<tokenIndex=769> { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 17)}?<p=17> op=(MUL<tokenIndex=550>|DIV<tokenIndex=552>) right=expr<tokenIndex=557,p=18> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 16)}?<p=16> op=(ADD<tokenIndex=570>|SUB<tokenIndex=572>) right=expr<tokenIndex=577,p=17> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 15)}?<p=15> op=(MAY_IG<tokenIndex=590>|MAYOR<tokenIndex=592>) right=expr<tokenIndex=597,p=16> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 14)}?<p=14> op=(MEN_IG<tokenIndex=610>|MENOR<tokenIndex=612>) right=expr<tokenIndex=617,p=15> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 13)}?<p=13> op=(IG_IG<tokenIndex=630>|DIF<tokenIndex=632>) right=expr<tokenIndex=637,p=14> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 12)}?<p=12> op=AND<tokenIndex=649> right=expr<tokenIndex=653,p=13> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 11)}?<p=11> op=OR<tokenIndex=665> right=expr<tokenIndex=669,p=12> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 10)}?<p=10> op=MAS_IGUAL<tokenIndex=681> right=expr<tokenIndex=685,p=11> {}
                  | {p.Precpred(p.GetParserRuleContext(), 9)}?<p=9> op=MENOS_IGUAL<tokenIndex=697> right=expr<tokenIndex=701,p=10> {}
                  | {p.Precpred(p.GetParserRuleContext(), 8)}?<p=8> op=MODULO<tokenIndex=713> right=expr<tokenIndex=717,p=9> {}
        )*
    ;
2023-08-24 18:00:21:467 grammar LogManager.java:25 added: (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (BLOCK (ALT {} (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 723))) (expr (ELEMENT_OPTIONS (= tokenIndex 725))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 727))) { $e = $expr.e }) (ALT (= list (listArray (ELEMENT_OPTIONS (= tokenIndex 735)))) { $e = $list.p}) (ALT (CORIZQ (ELEMENT_OPTIONS (= tokenIndex 741))) (listParams (ELEMENT_OPTIONS (= tokenIndex 743))) (CORDER (ELEMENT_OPTIONS (= tokenIndex 745))) { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 751))) {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT (STRING (ELEMENT_OPTIONS (= tokenIndex 757))) {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT (TRU (ELEMENT_OPTIONS (= tokenIndex 763))) { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT (FAL (ELEMENT_OPTIONS (= tokenIndex 769))) { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 17)}? (ELEMENT_OPTIONS (= p 17))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 550))) (DIV (ELEMENT_OPTIONS (= tokenIndex 552))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 557) (= p 18)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 16)}? (ELEMENT_OPTIONS (= p 16))) (= op (SET (ADD (ELEMENT_OPTIONS (= tokenIndex 570))) (SUB (ELEMENT_OPTIONS (= tokenIndex 572))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 577) (= p 17)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 15)}? (ELEMENT_OPTIONS (= p 15))) (= op (SET (MAY_IG (ELEMENT_OPTIONS (= tokenIndex 590))) (MAYOR (ELEMENT_OPTIONS (= tokenIndex 592))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 597) (= p 16)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 14)}? (ELEMENT_OPTIONS (= p 14))) (= op (SET (MEN_IG (ELEMENT_OPTIONS (= tokenIndex 610))) (MENOR (ELEMENT_OPTIONS (= tokenIndex 612))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 617) (= p 15)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 13)}? (ELEMENT_OPTIONS (= p 13))) (= op (SET (IG_IG (ELEMENT_OPTIONS (= tokenIndex 630))) (DIF (ELEMENT_OPTIONS (= tokenIndex 632))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 637) (= p 14)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 12)}? (ELEMENT_OPTIONS (= p 12))) (= op (AND (ELEMENT_OPTIONS (= tokenIndex 649)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 653) (= p 13)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 11)}? (ELEMENT_OPTIONS (= p 11))) (= op (OR (ELEMENT_OPTIONS (= tokenIndex 665)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 669) (= p 12)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 10)}? (ELEMENT_OPTIONS (= p 10))) (= op (MAS_IGUAL (ELEMENT_OPTIONS (= tokenIndex 681)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 685) (= p 11)))) {}) (ALT ({p.Precpred(p.GetParserRuleContext(), 9)}? (ELEMENT_OPTIONS (= p 9))) (= op (MENOS_IGUAL (ELEMENT_OPTIONS (= tokenIndex 697)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 701) (= p 10)))) {}) (ALT ({p.Precpred(p.GetParserRuleContext(), 8)}? (ELEMENT_OPTIONS (= p 8))) (= op (MODULO (ELEMENT_OPTIONS (= tokenIndex 713)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 717) (= p 9)))) {}))))))
2023-08-24 18:00:21:467 left-recursion LogManager.java:25 listParams returns [[]interface{} l]
    :   ( {} expr<tokenIndex=794> {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> COMA<tokenIndex=786> expr<tokenIndex=788> {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }
        )*
    ;
2023-08-24 18:00:21:469 grammar LogManager.java:25 added: (RULE listParams (returns []interface{} l) (BLOCK (ALT (BLOCK (ALT {} (expr (ELEMENT_OPTIONS (= tokenIndex 794))) {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (COMA (ELEMENT_OPTIONS (= tokenIndex 786))) (expr (ELEMENT_OPTIONS (= tokenIndex 788))) {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }))))))
2023-08-24 18:00:21:469 left-recursion LogManager.java:25 listArray returns [interfaces.Expression p]
    :   ( {} ID<tokenIndex=823> { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> CORIZQ<tokenIndex=813> expr<tokenIndex=815> CORDER<tokenIndex=817> { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }
        )*
    ;
2023-08-24 18:00:21:470 grammar LogManager.java:25 added: (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (BLOCK (ALT {} (ID (ELEMENT_OPTIONS (= tokenIndex 823))) { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (CORIZQ (ELEMENT_OPTIONS (= tokenIndex 813))) (expr (ELEMENT_OPTIONS (= tokenIndex 815))) (CORDER (ELEMENT_OPTIONS (= tokenIndex 817))) { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }))))))
2023-08-24 18:00:21:477 grammar LogManager.java:25 import INT=1
2023-08-24 18:00:21:477 grammar LogManager.java:25 import FLOAT=2
2023-08-24 18:00:21:477 grammar LogManager.java:25 import BOOL=3
2023-08-24 18:00:21:477 grammar LogManager.java:25 import STR=4
2023-08-24 18:00:21:477 grammar LogManager.java:25 import CHAR=5
2023-08-24 18:00:21:477 grammar LogManager.java:25 import TRU=6
2023-08-24 18:00:21:477 grammar LogManager.java:25 import FAL=7
2023-08-24 18:00:21:477 grammar LogManager.java:25 import PRINT=8
2023-08-24 18:00:21:477 grammar LogManager.java:25 import IF=9
2023-08-24 18:00:21:477 grammar LogManager.java:25 import ELSE=10
2023-08-24 18:00:21:477 grammar LogManager.java:25 import ELSE_IF=11
2023-08-24 18:00:21:477 grammar LogManager.java:25 import WHILE=12
2023-08-24 18:00:21:477 grammar LogManager.java:25 import FOR=13
2023-08-24 18:00:21:477 grammar LogManager.java:25 import IN=14
2023-08-24 18:00:21:477 grammar LogManager.java:25 import GUARD=15
2023-08-24 18:00:21:477 grammar LogManager.java:25 import CONTINUE=16
2023-08-24 18:00:21:478 grammar LogManager.java:25 import RETURN=17
2023-08-24 18:00:21:478 grammar LogManager.java:25 import SWITCH=18
2023-08-24 18:00:21:478 grammar LogManager.java:25 import BREAK=19
2023-08-24 18:00:21:478 grammar LogManager.java:25 import CASE=20
2023-08-24 18:00:21:478 grammar LogManager.java:25 import VAR=21
2023-08-24 18:00:21:478 grammar LogManager.java:25 import LET=22
2023-08-24 18:00:21:478 grammar LogManager.java:25 import D_APPEND=23
2023-08-24 18:00:21:478 grammar LogManager.java:25 import D_REMOVE=24
2023-08-24 18:00:21:478 grammar LogManager.java:25 import REPEATING=25
2023-08-24 18:00:21:478 grammar LogManager.java:25 import DEFAULT=26
2023-08-24 18:00:21:478 grammar LogManager.java:25 import COUNT=27
2023-08-24 18:00:21:478 grammar LogManager.java:25 import STRUCT=28
2023-08-24 18:00:21:479 grammar LogManager.java:25 import MUTATING=29
2023-08-24 18:00:21:479 grammar LogManager.java:25 import FUNC=30
2023-08-24 18:00:21:479 grammar LogManager.java:25 import SELF_D=31
2023-08-24 18:00:21:479 grammar LogManager.java:25 import PUNTO=32
2023-08-24 18:00:21:479 grammar LogManager.java:25 import INOUT=33
2023-08-24 18:00:21:479 grammar LogManager.java:25 import GUION_B=34
2023-08-24 18:00:21:479 grammar LogManager.java:25 import NUMBER=35
2023-08-24 18:00:21:479 grammar LogManager.java:25 import STRING=36
2023-08-24 18:00:21:479 grammar LogManager.java:25 import ID=37
2023-08-24 18:00:21:479 grammar LogManager.java:25 import DIF=38
2023-08-24 18:00:21:480 grammar LogManager.java:25 import IG_IG=39
2023-08-24 18:00:21:480 grammar LogManager.java:25 import MAS_IGUAL=40
2023-08-24 18:00:21:480 grammar LogManager.java:25 import MENOS_IGUAL=41
2023-08-24 18:00:21:480 grammar LogManager.java:25 import NOT=42
2023-08-24 18:00:21:480 grammar LogManager.java:25 import OR=43
2023-08-24 18:00:21:480 grammar LogManager.java:25 import AND=44
2023-08-24 18:00:21:480 grammar LogManager.java:25 import SOLO_AND=45
2023-08-24 18:00:21:480 grammar LogManager.java:25 import IG=46
2023-08-24 18:00:21:480 grammar LogManager.java:25 import MAY_IG=47
2023-08-24 18:00:21:480 grammar LogManager.java:25 import MEN_IG=48
2023-08-24 18:00:21:480 grammar LogManager.java:25 import MAYOR=49
2023-08-24 18:00:21:480 grammar LogManager.java:25 import MENOR=50
2023-08-24 18:00:21:480 grammar LogManager.java:25 import MUL=51
2023-08-24 18:00:21:480 grammar LogManager.java:25 import DIV=52
2023-08-24 18:00:21:481 grammar LogManager.java:25 import ADD=53
2023-08-24 18:00:21:481 grammar LogManager.java:25 import MODULO=54
2023-08-24 18:00:21:481 grammar LogManager.java:25 import SUB=55
2023-08-24 18:00:21:481 grammar LogManager.java:25 import PARIZQ=56
2023-08-24 18:00:21:481 grammar LogManager.java:25 import PARDER=57
2023-08-24 18:00:21:481 grammar LogManager.java:25 import LLAVEIZQ=58
2023-08-24 18:00:21:481 grammar LogManager.java:25 import LLAVEDER=59
2023-08-24 18:00:21:481 grammar LogManager.java:25 import D_PTS=60
2023-08-24 18:00:21:481 grammar LogManager.java:25 import CORIZQ=61
2023-08-24 18:00:21:481 grammar LogManager.java:25 import CORDER=62
2023-08-24 18:00:21:481 grammar LogManager.java:25 import COMA=63
2023-08-24 18:00:21:481 grammar LogManager.java:25 import PUNTO_COMA=64
2023-08-24 18:00:21:481 grammar LogManager.java:25 import WHITESPACE=65
2023-08-24 18:00:21:482 grammar LogManager.java:25 import COMMENT=66
2023-08-24 18:00:21:482 grammar LogManager.java:25 import LINE_COMMENT=67
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'Int'=1
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'Float'=2
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'Bool'=3
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'String'=4
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'Character'=5
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'true'=6
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'false'=7
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'print'=8
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'if'=9
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'else'=10
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'else if'=11
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'while'=12
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'for'=13
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'in'=14
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'guard'=15
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'continue'=16
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'return'=17
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'switch'=18
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'break'=19
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'case'=20
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'var'=21
2023-08-24 18:00:21:482 grammar LogManager.java:25 import 'let'=22
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '.append'=23
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '.remove'=24
2023-08-24 18:00:21:483 grammar LogManager.java:25 import 'repeating'=25
2023-08-24 18:00:21:483 grammar LogManager.java:25 import 'default'=26
2023-08-24 18:00:21:483 grammar LogManager.java:25 import 'count'=27
2023-08-24 18:00:21:483 grammar LogManager.java:25 import 'STRUCT'=28
2023-08-24 18:00:21:483 grammar LogManager.java:25 import 'mutating'=29
2023-08-24 18:00:21:483 grammar LogManager.java:25 import 'func'=30
2023-08-24 18:00:21:483 grammar LogManager.java:25 import 'self.'=31
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '.'=32
2023-08-24 18:00:21:483 grammar LogManager.java:25 import 'inout'=33
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '_'=34
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '!='=38
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '=='=39
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '+='=40
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '-='=41
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '!'=42
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '||'=43
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '&&'=44
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '&'=45
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '='=46
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '>='=47
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '<='=48
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '>'=49
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '<'=50
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '*'=51
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '/'=52
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '+'=53
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '%'=54
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '-'=55
2023-08-24 18:00:21:483 grammar LogManager.java:25 import '('=56
2023-08-24 18:00:21:484 grammar LogManager.java:25 import ')'=57
2023-08-24 18:00:21:484 grammar LogManager.java:25 import '{'=58
2023-08-24 18:00:21:484 grammar LogManager.java:25 import '}'=59
2023-08-24 18:00:21:484 grammar LogManager.java:25 import ':'=60
2023-08-24 18:00:21:484 grammar LogManager.java:25 import '['=61
2023-08-24 18:00:21:484 grammar LogManager.java:25 import ']'=62
2023-08-24 18:00:21:484 grammar LogManager.java:25 import ','=63
2023-08-24 18:00:21:484 grammar LogManager.java:25 import ';'=64
2023-08-24 18:00:21:484 grammar LogManager.java:25 tokens={INT=1, FLOAT=2, BOOL=3, STR=4, CHAR=5, TRU=6, FAL=7, PRINT=8, IF=9, ELSE=10, ELSE_IF=11, WHILE=12, FOR=13, IN=14, GUARD=15, CONTINUE=16, RETURN=17, SWITCH=18, BREAK=19, CASE=20, VAR=21, LET=22, D_APPEND=23, D_REMOVE=24, REPEATING=25, DEFAULT=26, COUNT=27, STRUCT=28, MUTATING=29, FUNC=30, SELF_D=31, PUNTO=32, INOUT=33, GUION_B=34, NUMBER=35, STRING=36, ID=37, DIF=38, IG_IG=39, MAS_IGUAL=40, MENOS_IGUAL=41, NOT=42, OR=43, AND=44, SOLO_AND=45, IG=46, MAY_IG=47, MEN_IG=48, MAYOR=49, MENOR=50, MUL=51, DIV=52, ADD=53, MODULO=54, SUB=55, PARIZQ=56, PARDER=57, LLAVEIZQ=58, LLAVEDER=59, D_PTS=60, CORIZQ=61, CORDER=62, COMA=63, PUNTO_COMA=64, WHITESPACE=65, COMMENT=66, LINE_COMMENT=67, 'Int'=1, 'Float'=2, 'Bool'=3, 'String'=4, 'Character'=5, 'true'=6, 'false'=7, 'print'=8, 'if'=9, 'else'=10, 'else if'=11, 'while'=12, 'for'=13, 'in'=14, 'guard'=15, 'continue'=16, 'return'=17, 'switch'=18, 'break'=19, 'case'=20, 'var'=21, 'let'=22, '.append'=23, '.remove'=24, 'repeating'=25, 'default'=26, 'count'=27, 'STRUCT'=28, 'mutating'=29, 'func'=30, 'self.'=31, '.'=32, 'inout'=33, '_'=34, '!='=38, '=='=39, '+='=40, '-='=41, '!'=42, '||'=43, '&&'=44, '&'=45, '='=46, '>='=47, '<='=48, '>'=49, '<'=50, '*'=51, '/'=52, '+'=53, '%'=54, '-'=55, '('=56, ')'=57, '{'=58, '}'=59, ':'=60, '['=61, ']'=62, ','=63, ';'=64}
2023-08-24 18:00:21:485 semantics LogManager.java:25 tokens={EOF=-1, INT=1, FLOAT=2, BOOL=3, STR=4, CHAR=5, TRU=6, FAL=7, PRINT=8, IF=9, ELSE=10, ELSE_IF=11, WHILE=12, FOR=13, IN=14, GUARD=15, CONTINUE=16, RETURN=17, SWITCH=18, BREAK=19, CASE=20, VAR=21, LET=22, D_APPEND=23, D_REMOVE=24, REPEATING=25, DEFAULT=26, COUNT=27, STRUCT=28, MUTATING=29, FUNC=30, SELF_D=31, PUNTO=32, INOUT=33, GUION_B=34, NUMBER=35, STRING=36, ID=37, DIF=38, IG_IG=39, MAS_IGUAL=40, MENOS_IGUAL=41, NOT=42, OR=43, AND=44, SOLO_AND=45, IG=46, MAY_IG=47, MEN_IG=48, MAYOR=49, MENOR=50, MUL=51, DIV=52, ADD=53, MODULO=54, SUB=55, PARIZQ=56, PARDER=57, LLAVEIZQ=58, LLAVEDER=59, D_PTS=60, CORIZQ=61, CORDER=62, COMA=63, PUNTO_COMA=64, WHITESPACE=65, COMMENT=66, LINE_COMMENT=67}
2023-08-24 18:00:21:485 semantics LogManager.java:25 strings={'Int'=1, 'Float'=2, 'Bool'=3, 'String'=4, 'Character'=5, 'true'=6, 'false'=7, 'print'=8, 'if'=9, 'else'=10, 'else if'=11, 'while'=12, 'for'=13, 'in'=14, 'guard'=15, 'continue'=16, 'return'=17, 'switch'=18, 'break'=19, 'case'=20, 'var'=21, 'let'=22, '.append'=23, '.remove'=24, 'repeating'=25, 'default'=26, 'count'=27, 'STRUCT'=28, 'mutating'=29, 'func'=30, 'self.'=31, '.'=32, 'inout'=33, '_'=34, '!='=38, '=='=39, '+='=40, '-='=41, '!'=42, '||'=43, '&&'=44, '&'=45, '='=46, '>='=47, '<='=48, '>'=49, '<'=50, '*'=51, '/'=52, '+'=53, '%'=54, '-'=55, '('=56, ')'=57, '{'=58, '}'=59, ':'=60, '['=61, ']'=62, ','=63, ';'=64}
2023-08-24 18:00:21:500 LL1 LogManager.java:25 
DECISION 0 in rule block
2023-08-24 18:00:21:500 LL1 LogManager.java:25 look=[null, null]
2023-08-24 18:00:21:500 LL1 LogManager.java:25 LL(1)? false
2023-08-24 18:00:21:500 LL1 LogManager.java:25 
DECISION 1 in rule instruction
2023-08-24 18:00:21:500 LL1 LogManager.java:25 look=[8, 9, {21..22}, 37, 18, 12, 13, 15, null]
2023-08-24 18:00:21:501 LL1 LogManager.java:25 LL(1)? false
2023-08-24 18:00:21:501 LL1 LogManager.java:25 
DECISION 2 in rule jumpstmt
2023-08-24 18:00:21:501 LL1 LogManager.java:25 look=[16, 17, 19, null]
2023-08-24 18:00:21:501 LL1 LogManager.java:25 LL(1)? false
2023-08-24 18:00:21:501 LL1 LogManager.java:25 
DECISION 3 in rule elsestmt
2023-08-24 18:00:21:501 LL1 LogManager.java:25 look=[10, null]
2023-08-24 18:00:21:501 LL1 LogManager.java:25 LL(1)? false
2023-08-24 18:00:21:501 LL1 LogManager.java:25 
DECISION 4 in rule else_ifstmt
2023-08-24 18:00:21:501 LL1 LogManager.java:25 look=[null, null]
2023-08-24 18:00:21:501 LL1 LogManager.java:25 LL(1)? false
2023-08-24 18:00:21:501 LL1 LogManager.java:25 
DECISION 5 in rule declarationstmt
2023-08-24 18:00:21:501 LL1 LogManager.java:25 look=[{21..22}, {21..22}]
2023-08-24 18:00:21:501 LL1 LogManager.java:25 LL(1)? false
2023-08-24 18:00:21:501 LL1 LogManager.java:25 
DECISION 6 in rule defaultsts
2023-08-24 18:00:21:501 LL1 LogManager.java:25 look=[26, 59]
2023-08-24 18:00:21:502 LL1 LogManager.java:25 LL(1)? true
2023-08-24 18:00:21:502 LL1 LogManager.java:25 
DECISION 7 in rule case
2023-08-24 18:00:21:502 LL1 LogManager.java:25 look=[null, {26, 59}]
2023-08-24 18:00:21:502 LL1 LogManager.java:25 LL(1)? false
2023-08-24 18:00:21:502 LL1 LogManager.java:25 
DECISION 8 in rule ig_type
2023-08-24 18:00:21:502 LL1 LogManager.java:25 look=[46, 39, 40, 41]
2023-08-24 18:00:21:502 LL1 LogManager.java:25 LL(1)? true
2023-08-24 18:00:21:502 LL1 LogManager.java:25 
DECISION 9 in rule reserv
2023-08-24 18:00:21:502 LL1 LogManager.java:25 look=[21, 22]
2023-08-24 18:00:21:502 LL1 LogManager.java:25 LL(1)? true
2023-08-24 18:00:21:502 LL1 LogManager.java:25 
DECISION 10 in rule types
2023-08-24 18:00:21:502 LL1 LogManager.java:25 look=[1, 2, 4, 3, 5, 61]
2023-08-24 18:00:21:502 LL1 LogManager.java:25 LL(1)? true
2023-08-24 18:00:21:502 LL1 LogManager.java:25 
DECISION 11 in rule expr
2023-08-24 18:00:21:502 LL1 LogManager.java:25 look=[56, 37, 61, 35, 36, 6, 7]
2023-08-24 18:00:21:502 LL1 LogManager.java:25 LL(1)? true
2023-08-24 18:00:21:502 LL1 LogManager.java:25 
DECISION 12 in rule expr
2023-08-24 18:00:21:502 LL1 LogManager.java:25 look=[null, null, null, null, null, null, null, null, null, null]
2023-08-24 18:00:21:502 LL1 LogManager.java:25 LL(1)? false
2023-08-24 18:00:21:502 LL1 LogManager.java:25 
DECISION 13 in rule expr
2023-08-24 18:00:21:502 LL1 LogManager.java:25 look=[null, null]
2023-08-24 18:00:21:502 LL1 LogManager.java:25 LL(1)? false
2023-08-24 18:00:21:503 LL1 LogManager.java:25 
DECISION 14 in rule listParams
2023-08-24 18:00:21:503 LL1 LogManager.java:25 look=[null, 62]
2023-08-24 18:00:21:503 LL1 LogManager.java:25 LL(1)? false
2023-08-24 18:00:21:503 LL1 LogManager.java:25 
DECISION 15 in rule listArray
2023-08-24 18:00:21:503 LL1 LogManager.java:25 look=[null, null]
2023-08-24 18:00:21:503 LL1 LogManager.java:25 LL(1)? false
