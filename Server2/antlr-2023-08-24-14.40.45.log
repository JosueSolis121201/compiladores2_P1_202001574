2023-08-24 14:40:45:651 grammar LogManager.java:25 before: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE STR (BLOCK (ALT 'String'))) (RULE CHAR (BLOCK (ALT 'Character'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'Let'))) (RULE D_APPEND (BLOCK (ALT '.append'))) (RULE D_REMOVE (BLOCK (ALT '.remove'))) (RULE REPEATING (BLOCK (ALT 'repeating'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE STRUCT (BLOCK (ALT 'STRUCT'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE SELF_D (BLOCK (ALT 'self.'))) (RULE PUNTO (BLOCK (ALT '.'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE GUION_B (BLOCK (ALT '_'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE MAS_IGUAL (BLOCK (ALT '+='))) (RULE MENOS_IGUAL (BLOCK (ALT '-='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE SOLO_AND (BLOCK (ALT '&'))) (RULE IG (BLOCK (ALT '='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE MODULO (BLOCK (ALT '%'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE D_PTS (BLOCK (ALT ':'))) (RULE CORIZQ (BLOCK (ALT '['))) (RULE CORDER (BLOCK (ALT ']'))) (RULE COMA (BLOCK (ALT ','))) (RULE PUNTO_COMA (BLOCK (ALT ';'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-24 14:40:45:666 grammar LogManager.java:25 after: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE STR (BLOCK (ALT 'String'))) (RULE CHAR (BLOCK (ALT 'Character'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'Let'))) (RULE D_APPEND (BLOCK (ALT '.append'))) (RULE D_REMOVE (BLOCK (ALT '.remove'))) (RULE REPEATING (BLOCK (ALT 'repeating'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE STRUCT (BLOCK (ALT 'STRUCT'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE SELF_D (BLOCK (ALT 'self.'))) (RULE PUNTO (BLOCK (ALT '.'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE GUION_B (BLOCK (ALT '_'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE MAS_IGUAL (BLOCK (ALT '+='))) (RULE MENOS_IGUAL (BLOCK (ALT '-='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE SOLO_AND (BLOCK (ALT '&'))) (RULE IG (BLOCK (ALT '='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE MODULO (BLOCK (ALT '%'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE D_PTS (BLOCK (ALT ':'))) (RULE CORIZQ (BLOCK (ALT '['))) (RULE CORDER (BLOCK (ALT ']'))) (RULE COMA (BLOCK (ALT ','))) (RULE PUNTO_COMA (BLOCK (ALT ';'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-24 14:40:45:912 grammar LogManager.java:25 before: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT asignacionstmt {}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk) }))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT reserv ID D_PTS types IG expr { $dec = instructions.NewDeclaration($VAR.line, $VAR.pos, $ID.text, $types.ty, $expr.e) }))) (RULE asignacionstmt (returns ) (BLOCK (ALT ID IG expr {}))) (RULE reserv (returns ) (BLOCK (ALT VAR {}) (ALT LET {}))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CHAR {}) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (BLOCK (ALT MUL) (ALT DIV))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT ADD) (ALT SUB))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MAY_IG) (ALT MAYOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MEN_IG) (ALT MENOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT IG_IG) (ALT DIF))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-24 14:40:45:915 grammar LogManager.java:25 after: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT asignacionstmt {}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk) }))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT reserv ID D_PTS types IG expr { $dec = instructions.NewDeclaration($VAR.line, $VAR.pos, $ID.text, $types.ty, $expr.e) }))) (RULE asignacionstmt (returns ) (BLOCK (ALT ID IG expr {}))) (RULE reserv (returns ) (BLOCK (ALT VAR {}) (ALT LET {}))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CHAR {}) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-24 14:40:45:916 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT asignacionstmt {}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk) }))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT reserv ID D_PTS types IG expr { $dec = instructions.NewDeclaration($VAR.line, $VAR.pos, $ID.text, $types.ty, $expr.e) }))) (RULE asignacionstmt (returns ) (BLOCK (ALT ID IG expr {}))) (RULE reserv (returns ) (BLOCK (ALT VAR {}) (ALT LET {}))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CHAR {}) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-24 14:40:45:916 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR SwiftGrammarLexer OPTIONS (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) RULES)
2023-08-24 14:40:45:931 left-recursion LogManager.java:25 expr returns [interfaces.Expression e]
    :   ( {} PARIZQ<tokenIndex=381> expr<tokenIndex=383> PARDER<tokenIndex=385> { $e = $expr.e } 
        | list=listArray<tokenIndex=393> { $e = $list.p} 
        | CORIZQ<tokenIndex=399> listParams<tokenIndex=401> CORDER<tokenIndex=403> { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) } 
        | NUMBER<tokenIndex=409>                             
    {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    } 
        | STRING<tokenIndex=415>
    {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    } 
        | TRU<tokenIndex=421> { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) } 
        | FAL<tokenIndex=427> { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 14)}?<p=14> op=(MUL<tokenIndex=256>|DIV<tokenIndex=258>) right=expr<tokenIndex=263,p=15> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 13)}?<p=13> op=(ADD<tokenIndex=276>|SUB<tokenIndex=278>) right=expr<tokenIndex=283,p=14> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 12)}?<p=12> op=(MAY_IG<tokenIndex=296>|MAYOR<tokenIndex=298>) right=expr<tokenIndex=303,p=13> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 11)}?<p=11> op=(MEN_IG<tokenIndex=316>|MENOR<tokenIndex=318>) right=expr<tokenIndex=323,p=12> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 10)}?<p=10> op=(IG_IG<tokenIndex=336>|DIF<tokenIndex=338>) right=expr<tokenIndex=343,p=11> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 9)}?<p=9> op=AND<tokenIndex=355> right=expr<tokenIndex=359,p=10> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 8)}?<p=8> op=OR<tokenIndex=371> right=expr<tokenIndex=375,p=9> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
        )*
    ;
2023-08-24 14:40:45:940 grammar LogManager.java:25 added: (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (BLOCK (ALT {} (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 381))) (expr (ELEMENT_OPTIONS (= tokenIndex 383))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 385))) { $e = $expr.e }) (ALT (= list (listArray (ELEMENT_OPTIONS (= tokenIndex 393)))) { $e = $list.p}) (ALT (CORIZQ (ELEMENT_OPTIONS (= tokenIndex 399))) (listParams (ELEMENT_OPTIONS (= tokenIndex 401))) (CORDER (ELEMENT_OPTIONS (= tokenIndex 403))) { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 409))) {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT (STRING (ELEMENT_OPTIONS (= tokenIndex 415))) {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT (TRU (ELEMENT_OPTIONS (= tokenIndex 421))) { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT (FAL (ELEMENT_OPTIONS (= tokenIndex 427))) { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 14)}? (ELEMENT_OPTIONS (= p 14))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 256))) (DIV (ELEMENT_OPTIONS (= tokenIndex 258))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 263) (= p 15)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 13)}? (ELEMENT_OPTIONS (= p 13))) (= op (SET (ADD (ELEMENT_OPTIONS (= tokenIndex 276))) (SUB (ELEMENT_OPTIONS (= tokenIndex 278))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 283) (= p 14)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 12)}? (ELEMENT_OPTIONS (= p 12))) (= op (SET (MAY_IG (ELEMENT_OPTIONS (= tokenIndex 296))) (MAYOR (ELEMENT_OPTIONS (= tokenIndex 298))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 303) (= p 13)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 11)}? (ELEMENT_OPTIONS (= p 11))) (= op (SET (MEN_IG (ELEMENT_OPTIONS (= tokenIndex 316))) (MENOR (ELEMENT_OPTIONS (= tokenIndex 318))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 323) (= p 12)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 10)}? (ELEMENT_OPTIONS (= p 10))) (= op (SET (IG_IG (ELEMENT_OPTIONS (= tokenIndex 336))) (DIF (ELEMENT_OPTIONS (= tokenIndex 338))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 343) (= p 11)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 9)}? (ELEMENT_OPTIONS (= p 9))) (= op (AND (ELEMENT_OPTIONS (= tokenIndex 355)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 359) (= p 10)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 8)}? (ELEMENT_OPTIONS (= p 8))) (= op (OR (ELEMENT_OPTIONS (= tokenIndex 371)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 375) (= p 9)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }))))))
2023-08-24 14:40:45:941 left-recursion LogManager.java:25 listParams returns [[]interface{} l]
    :   ( {} expr<tokenIndex=452> {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> COMA<tokenIndex=444> expr<tokenIndex=446> {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }
        )*
    ;
2023-08-24 14:40:45:942 grammar LogManager.java:25 added: (RULE listParams (returns []interface{} l) (BLOCK (ALT (BLOCK (ALT {} (expr (ELEMENT_OPTIONS (= tokenIndex 452))) {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (COMA (ELEMENT_OPTIONS (= tokenIndex 444))) (expr (ELEMENT_OPTIONS (= tokenIndex 446))) {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }))))))
2023-08-24 14:40:45:942 left-recursion LogManager.java:25 listArray returns [interfaces.Expression p]
    :   ( {} ID<tokenIndex=481> { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> CORIZQ<tokenIndex=471> expr<tokenIndex=473> CORDER<tokenIndex=475> { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }
        )*
    ;
2023-08-24 14:40:45:943 grammar LogManager.java:25 added: (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (BLOCK (ALT {} (ID (ELEMENT_OPTIONS (= tokenIndex 481))) { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (CORIZQ (ELEMENT_OPTIONS (= tokenIndex 471))) (expr (ELEMENT_OPTIONS (= tokenIndex 473))) (CORDER (ELEMENT_OPTIONS (= tokenIndex 475))) { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }))))))
2023-08-24 14:40:45:949 grammar LogManager.java:25 import INT=1
2023-08-24 14:40:45:949 grammar LogManager.java:25 import FLOAT=2
2023-08-24 14:40:45:950 grammar LogManager.java:25 import BOOL=3
2023-08-24 14:40:45:950 grammar LogManager.java:25 import STR=4
2023-08-24 14:40:45:950 grammar LogManager.java:25 import CHAR=5
2023-08-24 14:40:45:950 grammar LogManager.java:25 import TRU=6
2023-08-24 14:40:45:950 grammar LogManager.java:25 import FAL=7
2023-08-24 14:40:45:950 grammar LogManager.java:25 import PRINT=8
2023-08-24 14:40:45:950 grammar LogManager.java:25 import IF=9
2023-08-24 14:40:45:950 grammar LogManager.java:25 import ELSE=10
2023-08-24 14:40:45:950 grammar LogManager.java:25 import WHILE=11
2023-08-24 14:40:45:950 grammar LogManager.java:25 import FOR=12
2023-08-24 14:40:45:950 grammar LogManager.java:25 import IN=13
2023-08-24 14:40:45:950 grammar LogManager.java:25 import GUARD=14
2023-08-24 14:40:45:950 grammar LogManager.java:25 import CONTINUE=15
2023-08-24 14:40:45:951 grammar LogManager.java:25 import RETURN=16
2023-08-24 14:40:45:951 grammar LogManager.java:25 import SWITCH=17
2023-08-24 14:40:45:951 grammar LogManager.java:25 import BREAK=18
2023-08-24 14:40:45:951 grammar LogManager.java:25 import CASE=19
2023-08-24 14:40:45:951 grammar LogManager.java:25 import VAR=20
2023-08-24 14:40:45:951 grammar LogManager.java:25 import LET=21
2023-08-24 14:40:45:951 grammar LogManager.java:25 import D_APPEND=22
2023-08-24 14:40:45:951 grammar LogManager.java:25 import D_REMOVE=23
2023-08-24 14:40:45:951 grammar LogManager.java:25 import REPEATING=24
2023-08-24 14:40:45:951 grammar LogManager.java:25 import COUNT=25
2023-08-24 14:40:45:951 grammar LogManager.java:25 import STRUCT=26
2023-08-24 14:40:45:951 grammar LogManager.java:25 import MUTATING=27
2023-08-24 14:40:45:951 grammar LogManager.java:25 import FUNC=28
2023-08-24 14:40:45:952 grammar LogManager.java:25 import SELF_D=29
2023-08-24 14:40:45:952 grammar LogManager.java:25 import PUNTO=30
2023-08-24 14:40:45:952 grammar LogManager.java:25 import INOUT=31
2023-08-24 14:40:45:952 grammar LogManager.java:25 import GUION_B=32
2023-08-24 14:40:45:952 grammar LogManager.java:25 import NUMBER=33
2023-08-24 14:40:45:952 grammar LogManager.java:25 import STRING=34
2023-08-24 14:40:45:952 grammar LogManager.java:25 import ID=35
2023-08-24 14:40:45:952 grammar LogManager.java:25 import DIF=36
2023-08-24 14:40:45:952 grammar LogManager.java:25 import IG_IG=37
2023-08-24 14:40:45:952 grammar LogManager.java:25 import MAS_IGUAL=38
2023-08-24 14:40:45:952 grammar LogManager.java:25 import MENOS_IGUAL=39
2023-08-24 14:40:45:952 grammar LogManager.java:25 import NOT=40
2023-08-24 14:40:45:952 grammar LogManager.java:25 import OR=41
2023-08-24 14:40:45:952 grammar LogManager.java:25 import AND=42
2023-08-24 14:40:45:952 grammar LogManager.java:25 import SOLO_AND=43
2023-08-24 14:40:45:952 grammar LogManager.java:25 import IG=44
2023-08-24 14:40:45:952 grammar LogManager.java:25 import MAY_IG=45
2023-08-24 14:40:45:952 grammar LogManager.java:25 import MEN_IG=46
2023-08-24 14:40:45:952 grammar LogManager.java:25 import MAYOR=47
2023-08-24 14:40:45:952 grammar LogManager.java:25 import MENOR=48
2023-08-24 14:40:45:952 grammar LogManager.java:25 import MUL=49
2023-08-24 14:40:45:952 grammar LogManager.java:25 import DIV=50
2023-08-24 14:40:45:953 grammar LogManager.java:25 import ADD=51
2023-08-24 14:40:45:953 grammar LogManager.java:25 import MODULO=52
2023-08-24 14:40:45:953 grammar LogManager.java:25 import SUB=53
2023-08-24 14:40:45:953 grammar LogManager.java:25 import PARIZQ=54
2023-08-24 14:40:45:953 grammar LogManager.java:25 import PARDER=55
2023-08-24 14:40:45:953 grammar LogManager.java:25 import LLAVEIZQ=56
2023-08-24 14:40:45:953 grammar LogManager.java:25 import LLAVEDER=57
2023-08-24 14:40:45:953 grammar LogManager.java:25 import D_PTS=58
2023-08-24 14:40:45:953 grammar LogManager.java:25 import CORIZQ=59
2023-08-24 14:40:45:953 grammar LogManager.java:25 import CORDER=60
2023-08-24 14:40:45:953 grammar LogManager.java:25 import COMA=61
2023-08-24 14:40:45:953 grammar LogManager.java:25 import PUNTO_COMA=62
2023-08-24 14:40:45:953 grammar LogManager.java:25 import WHITESPACE=63
2023-08-24 14:40:45:953 grammar LogManager.java:25 import COMMENT=64
2023-08-24 14:40:45:953 grammar LogManager.java:25 import LINE_COMMENT=65
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'Int'=1
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'Float'=2
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'Bool'=3
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'String'=4
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'Character'=5
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'true'=6
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'false'=7
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'print'=8
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'if'=9
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'else'=10
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'while'=11
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'for'=12
2023-08-24 14:40:45:953 grammar LogManager.java:25 import 'in'=13
2023-08-24 14:40:45:954 grammar LogManager.java:25 import 'guard'=14
2023-08-24 14:40:45:954 grammar LogManager.java:25 import 'continue'=15
2023-08-24 14:40:45:954 grammar LogManager.java:25 import 'return'=16
2023-08-24 14:40:45:954 grammar LogManager.java:25 import 'switch'=17
2023-08-24 14:40:45:954 grammar LogManager.java:25 import 'break'=18
2023-08-24 14:40:45:954 grammar LogManager.java:25 import 'case'=19
2023-08-24 14:40:45:954 grammar LogManager.java:25 import 'var'=20
2023-08-24 14:40:45:954 grammar LogManager.java:25 import 'Let'=21
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '.append'=22
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '.remove'=23
2023-08-24 14:40:45:955 grammar LogManager.java:25 import 'repeating'=24
2023-08-24 14:40:45:955 grammar LogManager.java:25 import 'count'=25
2023-08-24 14:40:45:955 grammar LogManager.java:25 import 'STRUCT'=26
2023-08-24 14:40:45:955 grammar LogManager.java:25 import 'mutating'=27
2023-08-24 14:40:45:955 grammar LogManager.java:25 import 'func'=28
2023-08-24 14:40:45:955 grammar LogManager.java:25 import 'self.'=29
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '.'=30
2023-08-24 14:40:45:955 grammar LogManager.java:25 import 'inout'=31
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '_'=32
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '!='=36
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '=='=37
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '+='=38
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '-='=39
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '!'=40
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '||'=41
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '&&'=42
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '&'=43
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '='=44
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '>='=45
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '<='=46
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '>'=47
2023-08-24 14:40:45:955 grammar LogManager.java:25 import '<'=48
2023-08-24 14:40:45:956 grammar LogManager.java:25 import '*'=49
2023-08-24 14:40:45:956 grammar LogManager.java:25 import '/'=50
2023-08-24 14:40:45:956 grammar LogManager.java:25 import '+'=51
2023-08-24 14:40:45:956 grammar LogManager.java:25 import '%'=52
2023-08-24 14:40:45:956 grammar LogManager.java:25 import '-'=53
2023-08-24 14:40:45:956 grammar LogManager.java:25 import '('=54
2023-08-24 14:40:45:956 grammar LogManager.java:25 import ')'=55
2023-08-24 14:40:45:956 grammar LogManager.java:25 import '{'=56
2023-08-24 14:40:45:956 grammar LogManager.java:25 import '}'=57
2023-08-24 14:40:45:956 grammar LogManager.java:25 import ':'=58
2023-08-24 14:40:45:956 grammar LogManager.java:25 import '['=59
2023-08-24 14:40:45:956 grammar LogManager.java:25 import ']'=60
2023-08-24 14:40:45:956 grammar LogManager.java:25 import ','=61
2023-08-24 14:40:45:956 grammar LogManager.java:25 import ';'=62
2023-08-24 14:40:45:956 grammar LogManager.java:25 tokens={INT=1, FLOAT=2, BOOL=3, STR=4, CHAR=5, TRU=6, FAL=7, PRINT=8, IF=9, ELSE=10, WHILE=11, FOR=12, IN=13, GUARD=14, CONTINUE=15, RETURN=16, SWITCH=17, BREAK=18, CASE=19, VAR=20, LET=21, D_APPEND=22, D_REMOVE=23, REPEATING=24, COUNT=25, STRUCT=26, MUTATING=27, FUNC=28, SELF_D=29, PUNTO=30, INOUT=31, GUION_B=32, NUMBER=33, STRING=34, ID=35, DIF=36, IG_IG=37, MAS_IGUAL=38, MENOS_IGUAL=39, NOT=40, OR=41, AND=42, SOLO_AND=43, IG=44, MAY_IG=45, MEN_IG=46, MAYOR=47, MENOR=48, MUL=49, DIV=50, ADD=51, MODULO=52, SUB=53, PARIZQ=54, PARDER=55, LLAVEIZQ=56, LLAVEDER=57, D_PTS=58, CORIZQ=59, CORDER=60, COMA=61, PUNTO_COMA=62, WHITESPACE=63, COMMENT=64, LINE_COMMENT=65, 'Int'=1, 'Float'=2, 'Bool'=3, 'String'=4, 'Character'=5, 'true'=6, 'false'=7, 'print'=8, 'if'=9, 'else'=10, 'while'=11, 'for'=12, 'in'=13, 'guard'=14, 'continue'=15, 'return'=16, 'switch'=17, 'break'=18, 'case'=19, 'var'=20, 'Let'=21, '.append'=22, '.remove'=23, 'repeating'=24, 'count'=25, 'STRUCT'=26, 'mutating'=27, 'func'=28, 'self.'=29, '.'=30, 'inout'=31, '_'=32, '!='=36, '=='=37, '+='=38, '-='=39, '!'=40, '||'=41, '&&'=42, '&'=43, '='=44, '>='=45, '<='=46, '>'=47, '<'=48, '*'=49, '/'=50, '+'=51, '%'=52, '-'=53, '('=54, ')'=55, '{'=56, '}'=57, ':'=58, '['=59, ']'=60, ','=61, ';'=62}
2023-08-24 14:40:45:957 semantics LogManager.java:25 tokens={EOF=-1, INT=1, FLOAT=2, BOOL=3, STR=4, CHAR=5, TRU=6, FAL=7, PRINT=8, IF=9, ELSE=10, WHILE=11, FOR=12, IN=13, GUARD=14, CONTINUE=15, RETURN=16, SWITCH=17, BREAK=18, CASE=19, VAR=20, LET=21, D_APPEND=22, D_REMOVE=23, REPEATING=24, COUNT=25, STRUCT=26, MUTATING=27, FUNC=28, SELF_D=29, PUNTO=30, INOUT=31, GUION_B=32, NUMBER=33, STRING=34, ID=35, DIF=36, IG_IG=37, MAS_IGUAL=38, MENOS_IGUAL=39, NOT=40, OR=41, AND=42, SOLO_AND=43, IG=44, MAY_IG=45, MEN_IG=46, MAYOR=47, MENOR=48, MUL=49, DIV=50, ADD=51, MODULO=52, SUB=53, PARIZQ=54, PARDER=55, LLAVEIZQ=56, LLAVEDER=57, D_PTS=58, CORIZQ=59, CORDER=60, COMA=61, PUNTO_COMA=62, WHITESPACE=63, COMMENT=64, LINE_COMMENT=65}
2023-08-24 14:40:45:957 semantics LogManager.java:25 strings={'Int'=1, 'Float'=2, 'Bool'=3, 'String'=4, 'Character'=5, 'true'=6, 'false'=7, 'print'=8, 'if'=9, 'else'=10, 'while'=11, 'for'=12, 'in'=13, 'guard'=14, 'continue'=15, 'return'=16, 'switch'=17, 'break'=18, 'case'=19, 'var'=20, 'Let'=21, '.append'=22, '.remove'=23, 'repeating'=24, 'count'=25, 'STRUCT'=26, 'mutating'=27, 'func'=28, 'self.'=29, '.'=30, 'inout'=31, '_'=32, '!='=36, '=='=37, '+='=38, '-='=39, '!'=40, '||'=41, '&&'=42, '&'=43, '='=44, '>='=45, '<='=46, '>'=47, '<'=48, '*'=49, '/'=50, '+'=51, '%'=52, '-'=53, '('=54, ')'=55, '{'=56, '}'=57, ':'=58, '['=59, ']'=60, ','=61, ';'=62}
